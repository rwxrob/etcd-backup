#!/bin/bash

## etcd-backup creates and validates a backup snapshot of a single
## specific etcd database associated with a Kubernetes cluster and
## optionally removes any backups older than the LIMIT_DAYS_TO_KEEP.
## Note that this is only a portion of a full disaster recovery
## strategy depending on the type of applications running in the
## cluster.

# change the following to match your cluster

CACERT=/etc/kubernetes/pki/etcd/ca.crt
CERT=/etc/kubernetes/pki/etcd/server.crt
KEY=/etc/kubernetes/pki/etcd/server.key
PORT=2379
HOSTS=(control1 control2 control3)
LIMIT_DAYS_TO_KEEP=7

DIRS=(
  "/remote/backup/foo/$HOSTNAME/etcd"
  "/var/backup/k8s/etcd"
)

# ------------------ limit changes to anything below -----------------

export ETCDCTL_API=3
TSTAMP=$(date -u +%Y%m%dT%H%M%SZ)

ENDPOINTS=$(printf "https://%s:$PORT," "${HOSTS[@]}")
ENDPOINTS=${ENDPOINTS%,}

leader=$(etcdctl \
  --endpoints="$ENDPOINTS" \
  --cacert="$CACERT" \
  --cert="$CERT" \
  --key="$KEY" \
  endpoint status | grep true)
leader=${leader%%,*}

snapshot () {
  local dir=$1
  test -d "$dir" || mkdir -p "$dir"
  etcdctl \
    --endpoints="$leader" \
    --cacert="$CACERT" \
    --cert="$CERT" \
    --key="$KEY" \
    snapshot save "$dir/etcd-backup-$TSTAMP.db" >&2
}

validate () {
  local dir=$1
  test -z "$dir" && return 1
  etcdctl \
    --cacert="$CACERT" \
    --cert="$CERT" \
    --key="$KEY" \
    snapshot status "$dir/etcd-backup-$TSTAMP.db" >&2
}

before () {
  local limit=$1
  local fmt=$2
  [[ -n "$limit" && "$fmt" =~ \* ]] || return 1
  local dir=${fmt%/*}
  local name=${fmt##*/}
  local path=${fmt//\*/$limit}
  while IFS= read -r line; do
    [[ "$line" < "$path" ]] && echo "$line"
  done < <(find "$dir" -maxdepth 1 -type f -name "$name")
}

declare -i snapshot_fails=0
declare -i validate_fails=0
declare -i rotate_fails=0

for d in "${DIRS[@]}"; do
  snapshot "$d" || ((snapshot_fails++))
  validate "$d" || ((validate_fails++))
  (( "$LIMIT_DAYS_TO_KEEP" > 0 )) || continue
  limit=$(date -d "-$LIMIT_DAYS_TO_KEEP days" -u +%Y%m%dT%H%M%SZ)
  while IFS= read -r file; do
    echo "Deleting: $file" >&2
    rm "$file" || ((rotate_fails++))
  done < <(before "$limit" "$d/etcd-backup-*.db")
done

# originally intended for Icinga status

if (( rotate_fails > 0 )); then
  echo "WARNING"
  exit 1
fi

if (( snapshot_fails > 0 )); then
  echo "CRITICAL"
  exit 2
fi

if (( validate_fails > 0 )); then
  echo "CRITICAL"
  exit 2
fi

echo "OK"
